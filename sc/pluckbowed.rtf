{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf320
{\fonttbl\f0\fnil\fcharset0 Monaco;\f1\fmodern\fcharset0 Courier;\f2\fswiss\fcharset0 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red0\green115\blue0;\red191\green0\blue0;
\red96\green96\blue96;}
\deftab560
\pard\pardeftab560\ql\qnatural

\f0\fs18 \cf0 \
\cf2 SynthDef\cf0 (\cf3 \\pluckbow\cf0 , \{ \cf2 |drive_in = 0, \
					drive_point = 0.5, \
					noise_ratio = 0.01, \
					pitch_in = 300, \
					damping = 0.1, \
					refl = 0.90, \
					driver_smoothing = 0.99, \
					auto = 0, \
					pan = 0.5, \
					live = 1\
							|\cf0  \
		\
		\cf2 var\cf0  fb,inp;\
		\cf2 var\cf0  dl1,dl2,dr1,dr2,total_d_len,d_len1,d_len2,amp,mfac,slope,lev,tf,enveloped,output;\
				\
		\cf4 //1. lev needs to be a value between 0 and 1, when it is constantly 0.2 we get flute like sounds.\cf0 \
		\cf4 //2. we try to scale drive_in (for example slider values, or mouse-x), in such a way that the derivative\cf0 \
		\cf4 //of this value (for example mouse speed) can be something like 0.2. Smoothing helps in getting blown and bow sounds\cf0 \
		\
		lev = \cf2 Slope\cf0 .kr((drive_in * 0.00001)); \
		lev = \cf2 Integrator\cf0 .kr(lev, driver_smoothing);\
		lev = lev + auto;\
		\cf4 //lev = 0.2; //constant driving, very cool flute like\cf0 \
		\
		tf = 0.5 + lev;  \cf4 //wavetable shape param: higher value -> steeper slope -> pluck  0.001\cf0 \
		\
		total_d_len = pitch_in.reciprocal - \cf2 ControlRate\cf0 .ir.reciprocal; \cf4 //correction for controlrate block delay\cf0 \
		d_len1 = drive_point * (total_d_len/2); \cf4 //two times this one\cf0 \
		d_len2 = (1 - drive_point) * (total_d_len/2); \cf4 //and two times this one\cf0 \
		\
		\cf4 //audio\cf0 \
		fb = \cf2 LocalIn\cf0 .ar(1) * refl;\
		\cf4 //#pitch_anal,hf = Pitch.kr(fb,pitch_in,pitch_in*0.9,pitch_in*1.1); //variables not dynamically settable!!\cf0 \
				\
		\cf4 //our input is a dc offset + noise + whatever was fed back\cf0 \
		inp = \cf2 K2A\cf0 .ar((1 - noise_ratio) * lev) + \cf2 WhiteNoise\cf0 .ar(noise_ratio * lev);\
				\
		dl1 = \cf2 DelayC\cf0 .ar(fb  , 100.reciprocal , d_len1, 1); \cf4 //should be relative to pitch\cf0 \
		\
		\cf4 //"varying wavetable" func : 
\f1\fs24 y = p - 10^(-3 + 6*p) * x ,  makes it a pluck or a bow\cf0 \
		
\f0\fs18 amp = \cf2 Amplitude\cf0 .kr(dl1); \cf4 //table lookup x -> multiply y with inp \cf0 \
		slope = pow
\f1\fs24 (8,(-2 + 4 * tf));
\f0\fs18 		\
		
\f1\fs24 mfac = tf - amp*slope;
\f0\fs18 \
		mfac = mfac.max(0);\
		\
		\
		dl2 = \cf2 DelayC\cf0 .ar(dl1 + (inp * mfac), 100.reciprocal , d_len2, 1);  \
		enveloped = \cf2 EnvGen\cf0 .kr(
\f2\fs24  
\f0\fs18 \cf2 Env\cf0 .asr(0.005,0.9,0.05), live, doneAction:2) * \cf2 Clip\cf0 .ar(dl2, -0.95 , 0.95); \cf4 //to avoid ticks on instrument start and stop\cf0 \
		output = enveloped;\
		\
		\
		\cf2 Out\cf0 .ar(1, output * pan); \cf4 //out		\cf0 \
		\cf2 Out\cf0 .ar(0, output * (1 - pan)); \cf4 //out\cf0 \
		\
		dr2 = \cf2 DelayC\cf0 .ar( \cf2 LPF\cf0 .ar(dl2,damping*15000), 100.reciprocal , d_len2, 1); \cf4 //relative to pitch\cf0 \
		dr1 = \cf2 DelayC\cf0 .ar(dr2 - (inp * mfac), 100.reciprocal , d_len1, 1);		\
	\
		\
		\cf2 LocalOut\cf0 .ar(dr1); \cf4 //feedback into dl1\cf0 \
		\
	\}).send(s);   \cf4 //writeDefFile("/Users/lodewijk/dev/colours/svn/video-to-sound/sc/"); //writeDefFile("/Users/lodewijk/dev/colours/svn/video-to-sound/sc");\cf0 \
\
\
a = \cf2 Synth\cf0 (\cf5 "pluckbow"\cf0 , [\cf5 "auto"\cf0 ,0.05,\cf5 "pitch_in"\cf0 ,200,\cf5 "refl"\cf0 ,0.95]);\
a.set(\cf5 "live"\cf0 ,0);\
a = \cf2 Synth\cf0 (\cf5 "pluckbow"\cf0 );\
\
a = \cf2 Synth\cf0 (\cf5 "pluckbow"\cf0 , [\cf5 "auto"\cf0 ,0.2,\cf5 "pitch_in"\cf0 ,800,\cf5 "refl"\cf0 ,0.99,\cf5 "damping"\cf0 ,0.9]);\
\
\cf2 Server\cf0 .local.options.blockSize_(16);  \cf4 //scsynth -z 16\cf0 \
\cf2 Server\cf0 .local.options.blockSize;\
\
\
\cf4 //mooi damping 0.8\cf0 \
\cf4 //refl refl 0.995\cf0 \
\
}